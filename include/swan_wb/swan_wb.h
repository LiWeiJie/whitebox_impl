#ifndef _SWAN_WB_H_
#define _SWAN_WB_H_

#include <swan/swan.h>
#include <math/affine_transform.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SWAN_ENCRYPT 1
#define SWAN_DECRYPT 0

#define SWAN_PIECE_BIT 8   //how many bits in a piece

#if SWAN_PIECE_BIT == 8

typedef uint8_t swan_wb_unit;
typedef swan_wb_unit piece_t[1<<SWAN_PIECE_BIT];

#elif SWAN_PIECE_BIT == 16

typedef uint16_t swan_wb_unit;
typedef swan_wb_unit piece_t[1<<SWAN_PIECE_BIT];

#endif

enum swan_cipher_config_t {
    swan_cfg_128_64
} ;

static int swan_cfg_rounds[] = {1};

static int swan_cfg_blocksizes[] = {64};

typedef struct swan_wb_t{
    enum swan_cipher_config_t cfg;
    uint32_t rounds;
    uint32_t aff_in_round;
    uint32_t block_size;
    uint32_t piece_count;   // piece_count = block_size / 8, every 8 bit combined as a piece
    AffineTransform * round_aff;
    piece_t* lut; // piece_count look up table (combined with round key) needed for every round
    piece_t* SE; // start encode
    piece_t* EE; // end encode
} swan_whitebox_content;

/**
 * @brief swan whitebox encrypto function  
 * 
 * @param in both plaintext and ciphertext are ok, only accept one block: 16 uint8_t 
 * @param out the text that processed by swan_wb_ctx 
 * @param swan_wb_ctx swan_whitebox ctx, generated by int swan_wb_gen_tables(const uint8_t *key, swan_whitebox_content *swan_wb_ctx, int enc) or int swan_wb_gen_tables_with_dummyrounds(const uint8_t *key, swan_whitebox_content *swan_wb_ctx, int enc, int dummyrounds);
 */
int swan_wb_enc(swan_whitebox_content * swc, const uint8_t *in, uint8_t *out);

#define swan_wb_encrypt(swan_wb_ctx, in, out) swan_wb_enc(swan_wb_ctx, in, out)
#define swan_wb_decrypt(swan_wb_ctx, in, out) swan_wb_enc(swan_wb_ctx, in, out)

/**
 * @brief export swan_whitebox_content to byte
 * 
 * @param ctx a pointer of swan_whitebox_content
 * @param dest a pointer to a pointer of byte[], warning: must be free outside, must be NULL
 * @return int byte[] size
 */
int swan_wb_export_to_bytes(const swan_whitebox_content* ctx, uint8_t **dest) ;

/**
 * @brief import Swan Whitebox from str
 * 
 * @param source 
 * @return swan_whitebox_content * 
 */
int  swan_wb_import_from_bytes(const uint8_t *source, swan_whitebox_content* swc);

/**
 * @brief release the space of swan_whitebox_content
 * 
 * @param swan_whitebox_content 
 * @return int 0 is successful, otherwise fault
 */
int swan_whitebox_release(swan_whitebox_content *swc);


#ifdef __cplusplus
}
#endif

#endif //_SWAN_WB_H_
