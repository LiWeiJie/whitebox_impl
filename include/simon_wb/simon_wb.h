#ifndef _SIMON_WB_H_
#define _SIMON_WB_H_

#include <simon/simon.h>
#include <math/affine_transform.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif


#define SIMON_WHITEBOX_ROUND_MAX 68

#define SIMON_ENCRYPT 1
#define SIMON_DECRYPT 0

#define PIECE_SIZE 8   //how many bits in a piece
#if PIECE_SIZE == 8
typedef uint8_t piece_t[1<<PIECE_SIZE];
#elif PIECE_SIZE == 16
typedef uint16_t piece_t[1<<PIECE_SIZE];
#endif


typedef struct simon_wb_t{
    uint32_t rounds;
    int aff_in_round;
    int block_size;
    int piece_count;   // piece_count = block_size / 8, every 8 bit combined as a piece
    AffineTransform * round_aff;
    piece_t* lut; // piece_count look up table (combined with round key) needed for every round
    piece_t** and_table;  
    piece_t* SE; // start encode
    piece_t* EE; // end encode
} simon_whitebox_content;

/**
 * @brief simon whitebox encrypto function  
 * 
 * @param in both plaintext and ciphertext are ok, only accept one block: 16 uint8_t 
 * @param out the text that processed by simon_wb_ctx 
 * @param simon_wb_ctx simon_whitebox ctx, generated by int simon_wb_gen_tables(const uint8_t *key, simon_whitebox_content *simon_wb_ctx, int enc) or int simon_wb_gen_tables_with_dummyrounds(const uint8_t *key, simon_whitebox_content *simon_wb_ctx, int enc, int dummyrounds);
 */
void simon_wb_enc(const uint8_t *in, uint8_t *out, simon_whitebox_content * swc);

#define simon_wb_encrypt(in,out,simon_wb_ctx) simon_wb_enc(in, out, simon_wb_ctx);
#define simon_wb_decrypt(in,out,simon_wb_ctx)  simon_wb_encrypt(in,out,simon_wb_ctx)


/**
 * @brief free the space of simon_wb_ctx
 * 
 * @param simon_wb_ctx 
 * @return int 0 is successful, otherwise fault
 */
int simon_wb_free(simon_whitebox_content *swc);


#ifdef __cplusplus
}
#endif


#endif //_SIMON_WB_H_